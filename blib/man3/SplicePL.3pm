.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SplicePL 3pm"
.TH SplicePL 3pm "2010-06-23" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "Check List Before running the SplicePL, make sure: 1. BLAT binary is in the PATH environment variable. 2. SplicePL is in the PATH, and executable! 3. BLAT database file, i.e., the xxx.2bit file"
.IX Header "Check List Before running the SplicePL, make sure: 1. BLAT binary is in the PATH environment variable. 2. SplicePL is in the PATH, and executable! 3. BLAT database file, i.e., the xxx.2bit file"
Users need to make sure that several binaries are installed, including \s-1BLAT\s0, 
databases including
1. genome/chr1 to chrM.fa
2. genome/genome.2bit
.SS "run_blat Title   : run_blat Usage   : Function: run multiple Blat processes on a server Returns : Args    :"
.IX Subsection "run_blat Title   : run_blat Usage   : Function: run multiple Blat processes on a server Returns : Args    :"
.SS "split_fasta Title   : split_fasta Usage   : Function: split a fasta file into N pierces Returns : \s-1NULL\s0. Side effect is number of chunks of files will be created Args    : Three scalars, first is the path to the fasta file, Second is the number of chunks Third is the current path"
.IX Subsection "split_fasta Title   : split_fasta Usage   : Function: split a fasta file into N pierces Returns : NULL. Side effect is number of chunks of files will be created Args    : Three scalars, first is the path to the fasta file, Second is the number of chunks Third is the current path"
.ie n .SS "mark_reads_status Title   : mark_reads_status Usage   : mark_reads_status(""/path/to/psl_file"",""/path/to/fasta_file"") Function: Each read will be marked as u_pair u_forward u_reverse nu_pair nu_forward nu_reverse nomap Returns : Args    :  First string is the path to input \s-1PSL\s0 file Second is the path to the fasta file"
.el .SS "mark_reads_status Title   : mark_reads_status Usage   : mark_reads_status(``/path/to/psl_file'',``/path/to/fasta_file'') Function: Each read will be marked as u_pair u_forward u_reverse nu_pair nu_forward nu_reverse nomap Returns : Args    :  First string is the path to input \s-1PSL\s0 file Second is the path to the fasta file"
.IX Subsection "mark_reads_status Title   : mark_reads_status Usage   : mark_reads_status(/path/to/psl_file,/path/to/fasta_file) Function: Each read will be marked as u_pair u_forward u_reverse nu_pair nu_forward nu_reverse nomap Returns : Args    :  First string is the path to input PSL file Second is the path to the fasta file"
.SS "find_junctions Function : find junctions from a psl file col  9: strand col 10: seqID col 11: qSize col 14: chr col 18: block no col 19: blockSize col 21: tStart  (target start position) col start from 1 (not zero)"
.IX Subsection "find_junctions Function : find junctions from a psl file col  9: strand col 10: seqID col 11: qSize col 14: chr col 18: block no col 19: blockSize col 21: tStart  (target start position) col start from 1 (not zero)"
.SS "unique_junctions Function : Find unique junctions and count the coverage for each junction"
.IX Subsection "unique_junctions Function : Find unique junctions and count the coverage for each junction"
.SS "filter_human_splicesite Function: Filter the junctions with the splicing site patterns 1. \s-1GT\s0...AG 2. \s-1GC\s0...AG 3. \s-1AT\s0...AC"
.IX Subsection "filter_human_splicesite Function: Filter the junctions with the splicing site patterns 1. GT...AG 2. GC...AG 3. AT...AC"
.SS "revcom Function: reverse and complement a \s-1DNA\s0 sequence"
.IX Subsection "revcom Function: reverse and complement a DNA sequence"
.SS "check_total_memory Function: Retrieves the memory installed on this machine"
.IX Subsection "check_total_memory Function: Retrieves the memory installed on this machine"
.SS "usage Function: Print out usage message"
.IX Subsection "usage Function: Print out usage message"
.ie n .SS "prepare_paired_reads Title: prepare_paired_reads Usage : prepare_paired_reads(""/path/to/read1.fa"", ""/path/to/read2.fa"", ""/path/to/output.fa"") Function : Check fasta format; assign numerical \s-1ID\s0 such as 123f to forward, 123r to reverse read; combine two reads files to 1 file; make sure sequences are of same number in forward and reverse reads Returns : Args : First string is the path to forward read file Second string is the path to reverse read file Third string is the path to output fasta file"
.el .SS "prepare_paired_reads Title: prepare_paired_reads Usage : prepare_paired_reads(``/path/to/read1.fa'', ``/path/to/read2.fa'', ``/path/to/output.fa'') Function : Check fasta format; assign numerical \s-1ID\s0 such as 123f to forward, 123r to reverse read; combine two reads files to 1 file; make sure sequences are of same number in forward and reverse reads Returns : Args : First string is the path to forward read file Second string is the path to reverse read file Third string is the path to output fasta file"
.IX Subsection "prepare_paired_reads Title: prepare_paired_reads Usage : prepare_paired_reads(/path/to/read1.fa, /path/to/read2.fa, /path/to/output.fa) Function : Check fasta format; assign numerical ID such as 123f to forward, 123r to reverse read; combine two reads files to 1 file; make sure sequences are of same number in forward and reverse reads Returns : Args : First string is the path to forward read file Second string is the path to reverse read file Third string is the path to output fasta file"
.SS "fasta_dnaseq_no Function: Find total number of sequences in a fasta file; Also check the sanity of fasta file Args: The path to the fasta file"
.IX Subsection "fasta_dnaseq_no Function: Find total number of sequences in a fasta file; Also check the sanity of fasta file Args: The path to the fasta file"
.SS "gettime Function: Return current time formatted as: Tue Jun 22 08:13:20 2010"
.IX Subsection "gettime Function: Return current time formatted as: Tue Jun 22 08:13:20 2010"
.SS "mlog Function: Log time and message to stdout"
.IX Subsection "mlog Function: Log time and message to stdout"
.SS "mcall Function: Log subroutine name and arguments, then Call subroutine with arguments"
.IX Subsection "mcall Function: Log subroutine name and arguments, then Call subroutine with arguments"
